import { Request, Response } from "express";
import { User } from "./user.model";
import { Plan } from "../plans/plan.model";
import bcrypt from "bcryptjs";
import { OAuth2Client } from "google-auth-library";
import jwt, { SignOptions } from "jsonwebtoken";
import { AuthRequest } from "../utils/auth.middleware";
import {
  generateUniqueReferralCode,
  validateReferralCode,
} from "../utils/referral";
import { sendEmails } from "../utils/email.service";
import {
  referralSignupWelcomeEmail,
  referralRewardEmail,
} from "../utils/email-templates";
import { Ledger, TransactionType } from "../ledgers/ledger.model";

const JWT_SECRET =
  process.env.JWT_SECRET || "your-secret-key-change-in-production";
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || "7d";

const client = new OAuth2Client(process.env.GOOGLE_CLIENT_ID);

export const userController = {
  // Get all users
  getAllUsers: async (req: Request, res: Response) => {
    try {
      const users = await User.findAll({
        attributes: { exclude: ["passwordHash"] },
        include: [
          {
            model: Plan,
            as: "plan",
            attributes: ["id", "name", "price", "credits"],
          },
          {
            model: User,
            as: "referredByUser",
            attributes: ["id", "email", "fullName"],
          },
        ],
      });
      res.json(users);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  },

  // Get user by ID
  getUserById: async (req: Request, res: Response) => {
    try {
      const user = await User.findByPk(req.params.id, {
        attributes: { exclude: ["passwordHash"] },
        include: [
          {
            model: Plan,
            as: "plan",
            attributes: ["id", "name", "price", "credits"],
          },
          {
            model: User,
            as: "referredByUser",
            attributes: ["id", "email", "fullName"],
          },
        ],
      });
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      res.json(user);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  },

  // Create new user
  createUser: async (req: Request, res: Response) => {
    try {
      const { email, password, googleId, fullName, planId } = req.body;

      // Hash password if provided
      let passwordHash;
      if (password) {
        passwordHash = await bcrypt.hash(password, 10);
      }

      const user = await User.create({
        email,
        passwordHash,
        googleId,
        fullName,
        planId,
        // referralCode will be auto-generated by beforeCreate hook
      });

      const userResponse = user.toJSON();
      delete userResponse.passwordHash;

      res.status(201).json(userResponse);
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  },

  // Update user
  updateUser: async (req: Request, res: Response) => {
    try {
      const updates = req.body;

      // Don't allow direct password updates
      if (updates.password) {
        delete updates.password;
      }

      const user = await User.findByPk(req.params.id);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      await user.update(updates);
      const userResponse = user.toJSON();
      delete userResponse.passwordHash;

      res.json(userResponse);
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  },

  // Delete user
  deleteUser: async (req: Request, res: Response) => {
    try {
      const user = await User.findByPk(req.params.id);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      await user.destroy();
      res.json({ message: "User deleted successfully" });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  },

  // Get user credit balance
  getCreditBalance: async (req: Request, res: Response) => {
    try {
      const user = await User.findByPk(req.params.id, {
        attributes: ["creditBalance"],
      });
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      res.json({ creditBalance: user.creditBalance });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  },

  // Google OAuth authentication
  googleAuth: async (req: Request, res: Response) => {
    try {
      const { token: googleToken, plan, referralCode } = req.body;
      console.log("Received Google Auth Request:", {
        plan,
        referralCode: referralCode ? "***" : "none",
        tokenHeader: googleToken.substring(0, 10),
      });

      const ticket = await client.verifyIdToken({
        idToken: googleToken,
        audience: process.env.GOOGLE_CLIENT_ID || "",
      });

      const payload = ticket.getPayload();
      if (!payload || !payload.email) {
        return res.status(401).json({ message: "Invalid Google Token" });
      }

      console.log("Google Token Payload:", payload);

      const email = payload.email;
      const firstName = payload.given_name || "";
      const lastName = payload.family_name || "";
      const fullName = `${firstName} ${lastName}`.trim();
      const image = payload.picture || "";

      let user = await User.findOne({ where: { email } });
      let isNewUser = false;
      let referrer: User | null = null;

      if (!user) {
        isNewUser = true;
        // Create new user with Google auth
        const passwordHash = await bcrypt.hash(
          "GOOGLE_AUTH_USER_" + Math.random().toString(36),
          10,
        );

        let creditBalance = 8; // Base welcome bonus
        let referredById: number | undefined;

        // Validate and process referral code if provided
        if (referralCode) {
          referrer = await validateReferralCode(referralCode);
          if (referrer) {
            referredById = referrer.id;
            creditBalance = 18; // 8 base + 10 referral bonus
          } else {
            console.warn(
              `Invalid referral code provided: ${referralCode} for user ${email}`,
            );
            // Continue without referral if code is invalid
          }
        }

        user = await User.create({
          email,
          fullName,
          image,
          passwordHash,
          googleId: payload.sub,
          creditBalance,
          referredById,
          // referralCode will be auto-generated by beforeCreate hook
        });

        console.log(
          `New user created: ${user.email}, referralCode: ${user.referralCode}`,
        );

        // If user came from referral, add ledger entries and send emails
        if (referrer && referredById) {
          try {
            // Add referral bonus credits to new user via ledger
            await Ledger.create({
              userId: user.id,
              type: TransactionType.CREDIT,
              amount: 10,
              balanceAfter: creditBalance,
              referenceModel: "Referral",
              description: "Referral signup bonus",
            });

            // Add referral reward credits to referrer via ledger
            const referrerNewBalance = (referrer.creditBalance || 0) + 10;
            await referrer.increment("creditBalance", { by: 10 });

            await Ledger.create({
              userId: referrer.id,
              type: TransactionType.CREDIT,
              amount: 10,
              balanceAfter: referrerNewBalance,
              referenceModel: "Referral",
              description: `Referral reward - ${user.fullName || user.email} signed up`,
            });

            console.log(
              `Referral credits granted: ${user.email} +10, ${referrer.email} +10`,
            );

            // Send emails asynchronously (non-blocking)
            const emailsToSend = [
              {
                to: user.email,
                ...referralSignupWelcomeEmail(
                  user.fullName || "",
                  referrer.fullName || "",
                ),
              },
              {
                to: referrer.email,
                ...referralRewardEmail(
                  referrer.fullName || "",
                  user.fullName || "",
                ),
              },
            ];

            sendEmails(emailsToSend).catch((err) => {
              console.error("Error sending referral emails:", err);
            });
          } catch (ledgerError) {
            console.error("Error processing referral credits:", ledgerError);
            // Don't fail the signup if ledger/email fails
          }
        }
      } else {
        // Update existing user
        const updates: any = {};
        if (!user.fullName && fullName) updates.fullName = fullName;
        if (!user.googleId && payload.sub) updates.googleId = payload.sub;
        if (image) updates.image = image;

        // Never update referralCode or referredById for existing users
        if (Object.keys(updates).length > 0) {
          await user.update(updates);
        }

        console.log(`Existing user updated: ${user.email}`);
      }

      const userResponse = user.toJSON();
      delete userResponse.passwordHash;

      // Generate JWT token
      const signOptions: SignOptions = { expiresIn: JWT_EXPIRES_IN as any };
      const token = jwt.sign(
        {
          id: user.id.toString(),
          email: user.email,
          fullName: user.fullName,
          role: "user",
        },
        JWT_SECRET,
        signOptions,
      );

      res.json({ user: userResponse, token });
    } catch (error: any) {
      console.error("Google Auth Error:", error);
      res.status(401).json({
        message: "Invalid Google Token",
        error: error.toString(),
      });
    }
  },

  // Get current user profile (renamed from verify-payment)
  getCurrentUser: async (req: AuthRequest, res: Response) => {
    try {
      // Extract email from JWT token (set by verifyUserToken middleware)
      const email = req.user?.email;

      if (!email) {
        return res.status(401).json({ message: "Authentication required" });
      }

      const user = await User.findOne({
        where: { email },
        attributes: { exclude: ["passwordHash"] },
        include: [
          {
            model: Plan,
            as: "plan",
            attributes: ["id", "name", "price", "credits"],
          },
          {
            model: User,
            as: "referredByUser",
            attributes: ["id", "email", "fullName"],
          },
        ],
      });

      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      res.json({ user });
    } catch (error: any) {
      res.status(500).json({ message: "Server error", error: error.message });
    }
  },

  // Update current user's referral code (self-service)
  updateMyReferralCode: async (req: AuthRequest, res: Response) => {
    try {
      const email = req.user?.email;
      const { referralCode } = req.body;

      if (!email) {
        return res.status(401).json({
          error: "Authentication required",
          code: "AUTH_REQUIRED",
        });
      }

      if (!referralCode || typeof referralCode !== "string") {
        return res.status(400).json({
          error: "Referral code is required",
          code: "REFERRAL_CODE_REQUIRED",
        });
      }

      const normalizedReferralCode = referralCode
        .toLowerCase()
        .trim()
        .replace(/\s+/g, "-");

      const validCodePattern = /^[a-z0-9+-]{3,50}$/;
      if (!validCodePattern.test(normalizedReferralCode)) {
        return res.status(400).json({
          error:
            "Referral code must be 3-50 characters and contain only lowercase letters, numbers, +, or -",
          code: "INVALID_REFERRAL_CODE_FORMAT",
        });
      }

      const user = await User.findOne({ where: { email } });
      if (!user) {
        return res.status(404).json({
          error: "User not found",
          code: "USER_NOT_FOUND",
        });
      }

      if (user.referralCode === normalizedReferralCode) {
        return res.status(200).json({
          message: "Referral code is already set to this value",
          referralCode: user.referralCode,
        });
      }

      const referralUsageCount = await User.count({
        where: { referredById: user.id },
      });

      if (referralUsageCount > 0) {
        return res.status(409).json({
          error:
            "Referral code cannot be changed because it has already been used",
          code: "REFERRAL_CODE_LOCKED",
        });
      }

      const existingUserWithCode = await User.findOne({
        where: { referralCode: normalizedReferralCode },
      });

      if (existingUserWithCode && existingUserWithCode.id !== user.id) {
        return res.status(409).json({
          error: "This referral code is already taken",
          code: "REFERRAL_CODE_TAKEN",
        });
      }

      await user.update({ referralCode: normalizedReferralCode });

      return res.json({
        message: "Referral code updated successfully",
        referralCode: user.referralCode,
      });
    } catch (error: any) {
      console.error("Error updating referral code:", error);
      return res.status(500).json({
        error: "Failed to update referral code",
        code: "REFERRAL_CODE_UPDATE_FAILED",
      });
    }
  },

  // Test email sending (for development/testing only)
  sendTestEmail: async (req: Request, res: Response) => {
    try {
      const { email, newUserName, referrerName, emailType } = req.body;

      // Validate required fields
      if (!email) {
        return res.status(400).json({ error: "Email address is required" });
      }

      if (!newUserName || !referrerName) {
        return res
          .status(400)
          .json({ error: "newUserName and referrerName are required" });
      }

      if (!emailType || !["welcome", "reward"].includes(emailType)) {
        return res.status(400).json({
          error: 'emailType must be either "welcome" or "reward"',
        });
      }

      console.log("ðŸ“§ Sending test email:", {
        email,
        emailType,
        newUserName,
        referrerName,
      });

      if (emailType === "welcome") {
        const template = referralSignupWelcomeEmail(newUserName, referrerName);
        await sendEmails([
          {
            to: email,
            subject: template.subject,
            htmlContent: template.htmlContent,
            textContent: template.textContent,
          },
        ]);
      } else if (emailType === "reward") {
        const template = referralRewardEmail(referrerName, newUserName);
        await sendEmails([
          {
            to: email,
            subject: template.subject,
            htmlContent: template.htmlContent,
            textContent: template.textContent,
          },
        ]);
      }

      res.json({
        message: `Test ${emailType} email sent successfully to ${email}`,
        email,
        emailType,
      });
    } catch (error: any) {
      console.error("Error sending test email:", error);
      res.status(500).json({
        error: "Failed to send test email",
        details: error.message,
      });
    }
  },
};
